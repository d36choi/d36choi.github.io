---
layout: post
title: item 86 Serializable을 구현할 지는 신중하라
date: 2024-06-15 23:01 +0900
categories: ["이펙티브 자바"]
tags: [java]
---

## 직렬화 구현의 오해
- `implement Serializable` 만 하면 끝난다고 생각한다
- 더이상 신경쓸게 없어보이지만 크나큰 오해다

### 직렬화 인터페이스를 구현하면 릴리스 한 뒤에는 수정이 어렵다
- 직렬화된 바이트 스트림도 하나의 공개 API가 된다.
- 즉 이 클래스가 널리 퍼지면 그 직렬화 형태도 다른 공개API와 마찬가지로 영원히 지원해야 하는 것이다
- 직렬화 형태에서는 클래스의 private, package-private 까지 전부 공개하는 꼴이 되고 이건 캡슐화를 깨뜨린다
- 정보 은닉 원칙에도 위배 되낟

## 대표적인 클래스 개선 방해 사례
- UUID 직렬버전
- 모든 직렬화클래스는 고유 식별번호를 부여받는다
- serialVersionUID 라는 static final long 필드이다.
- 명시하지 않는 경우 해시 함수를 통해 런타임에 클래스안에 생성된다
- 이 값에는 클래스이름,인터페이스, 컴파일러의 클래스멤버들이 고려된다
- 그래서 하나라도 수정한다면 직렬 버전 UID값도 변한다

## 2번째 문제. 버그와 보안구멍이 생길 위험
- 객체는 생성자를 사용해 만드는게 기본이다
- 즉, 직렬화는 언어의 기본메커니즘을 우회하는 객체 생성 기법이다
- 즉, 역직렬화는 `숨은 생성자` 가 된다
- 이 생성자는 전면에 드러나지 않아 `생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 볼 수 없게해야한다` 라는 사실을 떠올리기 어렵다
- 허가되지 않은 접근에 쉽게 노출된다

## 3번째 문제. 해당 클래스의 신버전 릴리즈 시 테스트 범위가 늘어난다
- 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 전 버전으로 역직렬화 할 수 있는지 그 반대도 되는지 테스트가 필요
- 따라서 테스트량이 버전 개선 횟수에 비례해 증가한다

## 가볍게 결정할 사안이 아니다
- 단 객체 전송 및 저장에 자바 직렬화이용하는 프레임워크면 선택 여지가 없다
- 구현에 따른 비용이 적지 않으나 클래스 설계시 그 비용과 이득을 잘 저울질 해야 한다
- BigInteger와 Instant 같은 '값' 클래스와 컬렉션 클래스들은 Serializable을 구현하고, 스레드 풀처럼 '동작'하는 객체 표현 클래스는 대부분 Serializable을 구현하지 않았다.

## 상속용으로 설계된 클래스나 인터페이스는 Serializable을 확장해선 안 된다.
- 이 규칙을 따르지 않으면 그 클래스를 확장하거나 인터페이스를 구현한 클래스에도 똑같이 부담이 생김
- Throwable, Component 가 직렬화 구현한 클래스 예시다

## 주의점
- 인스턴스 필드 값 중 불변식 보장해야 할 게 있다면 반드시 하위메서드에서 finalize 를 재정의못하게 해야한다
- 필드 중 원시 값으로 초기화되면 위배되는 불변식이 있다면 readObjectNoData를 반드시 추가해야 한다.

```java
private void readObjectNoData() throws InvalidObjectException {
    throw new InvalidObjectException("스트림 데이터가 필요합니다.");
}
```

## 내부 클래스는 직렬화를 구현하지말아야 한다
- 내부 클래스에는 바깥 인스턴스 참조와 유효범위 안의 지역 변수의 값들을 저장하기 위해 컴파일러가 생성한 필드가 자동 추가됨
- 내부 클래스에 대한 기본 직렬화 형태는 분명하지가 않다
- 단 정적 멤버클래스는 직렬화를 구현해도 된다


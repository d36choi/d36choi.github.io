---
layout: post
title: item 83 지연 초기화는 신중히 사용하라
date: 2024-06-08 23:01 +0900
categories: ["이펙티브 자바"]
tags: [java]
---

## 지연 초기화란
- 필드 초기화 시점을 그 값이 처음 필요한 시점까지 늦추는 기법
- 최적화 용도로 쓰이거나 클래스 초기화때 발생하는 순환 문제를 해결하는 효과도 있다

## 필요할때 까지는 하지마라
- 생성시 초기화 비용은 줄지만 그 초기화 필드에 접근하는 비용은 커진다
- 실제로는 성능을 느려지게 할 수도 있다

## 필요한 때
- 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮은 반면 그 필드를 초기화하는 비용이 크다면
- 사실 이걸 판단하려면 지연초기화 전후 성능 비교해야만 함

## 멀티스레드 환경에서의 지연 초기화
- 지연 초기화 하는 필드를 둘 이상의 스레드가 공유한다면 어떤 형태로는 반드시 동기화가 필요
- **대부분, 일반적인 초기화가 지연 초기화보다 낫다**


## 지연 초기화가 초기화 순환성을 깨뜨릴 것 같으면
- 자바의 초기화 순서가 불명확해서 초기화 순환성 문제가 발생할 수 있다.
- 지연 초기화가 초기화 순환성을 깨뜨려야 한다면 synchronized를 사용하자. 가장 간단하고 명확한 방법이다.


```java

private FieldType field;
private synchronized FieldType getField() {
    if (field == null)
        field = computeFieldValue();
    return field;
}
```

## 지연초기화해야하면 이중 검사를 해라
- 초기화된 필드에 접근할 때의 동기화 비용을 없애 준다
- 한번은 동기화 없이, (만약 초기화 안되어 있다면) 동기화 하여 검사한다
- 두번 째 검사에서도 초기화되어있지 않다면 필드를 초기화 시킨다
- volatile로 선언해야만 한다

```java
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    if (result != null) { // 첫 번째 검사 (락 사용 안 함)
        return result;
    
    synchronized(this) {
        if (field == null) // 두 번째 검사 (락 사용)
            field = computeFieldValue();
        return field;
    }
}
```

- result라는 지역변수를 쓰면 성능도 높여준다
- 이미 초기화된 상황에서 그 필드를 딱 한번만 읽도록 보장한다 (volatile과 관련이 있는 내용인듯 하다?)


## 요약
- 대부분 필드는 지연시키지말고 곧바로 초기화 해야 한다
- 초기화 순환을 막거나 성능을 위해 구현해야한다면 올바르게 사용하자
- 인스턴스필드 = 이중검사
- 정적 필드 = 지연 초기화 홀더 클래스
- 반복해 초기화해도 괜찮으면 = 단일검사 관용구
- 위 3가지 케이스에 대해 방법을 기억하자
